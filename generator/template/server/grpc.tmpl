// Autogenerated by application-generator

package server

import (
	generated "application-emulator/src/generated"
	"application-emulator/src/stressors"
	"application-emulator/src/util"
	model "application-model"
	generated_model "application-model/generated"
	"context"
	"log"

	"google.golang.org/grpc"
)

{{ range . }}
type {{ goname .Name }}Impl struct {
	generated.Unimplemented{{ goname .Name }}Server
	{{ range .Endpoints }}
	{{ goname .Name }}Info *model.Endpoint
	{{ end }}
}
{{ end }}

{{ range $service := . }}
{{ range $endpoint := .Endpoints }}
func (s *{{ goname $service.Name }}Impl) {{ goname $endpoint.Name }}(ctx context.Context, request *generated_model.Request) (*generated_model.Response, error) {
	trace := util.TraceEndpointCall(s.{{ goname $endpoint.Name }}Info, "gRPC")
	response := &generated_model.Response{
		Endpoint: s.{{ goname $endpoint.Name }}Info.Name,
		Tasks:    stressors.Exec(request, s.{{ goname $endpoint.Name }}Info),
	}
	util.LogEndpointCall(trace)
	return response, nil
}
{{ end }}
{{ end }}

func RegisterGeneratedService(registrar grpc.ServiceRegistrar, endpoints []model.Endpoint) {
	switch util.ServiceName {
	{{ range . }}
	case "{{ .Name }}": 
		impl := {{ goname .Name }}Impl{}
		for _, endpoint := range endpoints {
			switch endpoint.Name {
			{{ range .Endpoints }}
			case "{{ .Name }}":
				impl.{{ goname .Name }}Info = &endpoint
			{{ end }}
			default:
				log.Fatalf("Service %s got invalid gRPC endpoint %s", util.ServiceName, endpoint.Name)
			}
		}
		generated.Register{{ goname .Name }}Server(registrar, &impl)
	{{ end }}
	}
}